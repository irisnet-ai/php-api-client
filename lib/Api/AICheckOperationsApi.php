<?php
/**
 * AICheckOperationsApi
 * PHP version 8.1
 *
 * @category Class
 * @package  Irisnet\API\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Irisnet API
 *
 * Artificial Intelligence (AI) for image- and video-processing in real-time. This is an interactive documentation where you can quickly look up the endpoints and their schemas, while having the opportunity to try things out for yourself.  In the list below, you can see the available endpoints of the API, which can be expanded by clicking on them. Each expanded endpoint lists the request parameters (if available) and the request body (if available). The request body can list some example bodies and the schema, explaining each model in detail.  Additionally you'll find a 'Try it out' button that allows you to enter your custom parameters and custom body and execute that against the API. <b>Be sure to enter your license key to authorize the requests before using this documentation interactively.</b>  The responses section in the expanded endpoint lists the possible responses with their corresponding status codes. If you've executed an API call it will also show you the response from the server.  Underneath the endpoints you'll find the model schemas. These are the models used for the requests and responses. If you click on the right arrow, you can expand the model and get a description of the model and the model parameters. For nested models, you can keep clicking the right arrow for further details.  Clicking the link below the title at the top of this page opens the [OpenAPI specification](https://swagger.io/specification/) (OAS3) in JSON format. The OAS3 Spec allows the generation of clients in many programming languages. There are several free client generators available that can be used to get started easily.
 *
 * The version of the OpenAPI document: v2
 * Contact: info@irisnet.de
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.14.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Irisnet\API\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use Irisnet\API\Client\ApiException;
use Irisnet\API\Client\Configuration;
use Irisnet\API\Client\FormDataProcessor;
use Irisnet\API\Client\HeaderSelector;
use Irisnet\API\Client\ObjectSerializer;

/**
 * AICheckOperationsApi Class Doc Comment
 *
 * @category Class
 * @package  Irisnet\API\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class AICheckOperationsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'ageVerification' => [
            'application/json',
        ],
        'checkIdDocument' => [
            'application/json',
        ],
        'checkImage' => [
            'application/json',
        ],
        'checkPoaDocument' => [
            'application/json',
        ],
        'checkStream' => [
            'application/json',
        ],
        'checkText' => [
            'application/json',
        ],
        'checkVideo' => [
            'application/json',
        ],
        'faceAuthentication' => [
            'application/json',
        ],
        'liveDocumentCheck' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation ageVerification
     *
     * Perform an age verfication check for a given selfie with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  \Irisnet\API\Client\Model\BiometricCheckRequestData $biometricCheckRequestData The BiometricCheckRequestData containing data needed for the age verification check. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ageVerification'] to see the possible values for this operation
     *
     * @throws \Irisnet\API\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Irisnet\API\Client\Model\CheckResult|\Irisnet\API\Client\Model\ApiNotice
     */
    public function ageVerification($configId, $biometricCheckRequestData, string $contentType = self::contentTypes['ageVerification'][0])
    {
        list($response) = $this->ageVerificationWithHttpInfo($configId, $biometricCheckRequestData, $contentType);
        return $response;
    }

    /**
     * Operation ageVerificationWithHttpInfo
     *
     * Perform an age verfication check for a given selfie with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  \Irisnet\API\Client\Model\BiometricCheckRequestData $biometricCheckRequestData The BiometricCheckRequestData containing data needed for the age verification check. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ageVerification'] to see the possible values for this operation
     *
     * @throws \Irisnet\API\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Irisnet\API\Client\Model\CheckResult|\Irisnet\API\Client\Model\ApiNotice, HTTP status code, HTTP response headers (array of strings)
     */
    public function ageVerificationWithHttpInfo($configId, $biometricCheckRequestData, string $contentType = self::contentTypes['ageVerification'][0])
    {
        $request = $this->ageVerificationRequest($configId, $biometricCheckRequestData, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    return $this->handleResponseWithDataType(
                        '\Irisnet\API\Client\Model\CheckResult',
                        $request,
                        $response,
                    );
                case 402:
                    return $this->handleResponseWithDataType(
                        '\Irisnet\API\Client\Model\ApiNotice',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Irisnet\API\Client\Model\CheckResult',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Irisnet\API\Client\Model\CheckResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Irisnet\API\Client\Model\ApiNotice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation ageVerificationAsync
     *
     * Perform an age verfication check for a given selfie with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  \Irisnet\API\Client\Model\BiometricCheckRequestData $biometricCheckRequestData The BiometricCheckRequestData containing data needed for the age verification check. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ageVerification'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ageVerificationAsync($configId, $biometricCheckRequestData, string $contentType = self::contentTypes['ageVerification'][0])
    {
        return $this->ageVerificationAsyncWithHttpInfo($configId, $biometricCheckRequestData, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ageVerificationAsyncWithHttpInfo
     *
     * Perform an age verfication check for a given selfie with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  \Irisnet\API\Client\Model\BiometricCheckRequestData $biometricCheckRequestData The BiometricCheckRequestData containing data needed for the age verification check. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ageVerification'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ageVerificationAsyncWithHttpInfo($configId, $biometricCheckRequestData, string $contentType = self::contentTypes['ageVerification'][0])
    {
        $returnType = '\Irisnet\API\Client\Model\CheckResult';
        $request = $this->ageVerificationRequest($configId, $biometricCheckRequestData, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ageVerification'
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  \Irisnet\API\Client\Model\BiometricCheckRequestData $biometricCheckRequestData The BiometricCheckRequestData containing data needed for the age verification check. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ageVerification'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ageVerificationRequest($configId, $biometricCheckRequestData, string $contentType = self::contentTypes['ageVerification'][0])
    {

        // verify the required parameter 'configId' is set
        if ($configId === null || (is_array($configId) && count($configId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $configId when calling ageVerification'
            );
        }

        // verify the required parameter 'biometricCheckRequestData' is set
        if ($biometricCheckRequestData === null || (is_array($biometricCheckRequestData) && count($biometricCheckRequestData) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $biometricCheckRequestData when calling ageVerification'
            );
        }


        $resourcePath = '/v2/age-verification/{configId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($configId !== null) {
            $resourcePath = str_replace(
                '{' . 'configId' . '}',
                ObjectSerializer::toPathValue($configId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($biometricCheckRequestData)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($biometricCheckRequestData));
            } else {
                $httpBody = $biometricCheckRequestData;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('LICENSE-KEY');
        if ($apiKey !== null) {
            $headers['LICENSE-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation checkIdDocument
     *
     * Check an id document with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  \Irisnet\API\Client\Model\DocumentCheckRequestData $documentCheckRequestData The DocumentCheckRequestData containing data needed for the id document check. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkIdDocument'] to see the possible values for this operation
     *
     * @throws \Irisnet\API\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Irisnet\API\Client\Model\CheckResult|\Irisnet\API\Client\Model\ApiNotice
     */
    public function checkIdDocument($configId, $documentCheckRequestData, string $contentType = self::contentTypes['checkIdDocument'][0])
    {
        list($response) = $this->checkIdDocumentWithHttpInfo($configId, $documentCheckRequestData, $contentType);
        return $response;
    }

    /**
     * Operation checkIdDocumentWithHttpInfo
     *
     * Check an id document with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  \Irisnet\API\Client\Model\DocumentCheckRequestData $documentCheckRequestData The DocumentCheckRequestData containing data needed for the id document check. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkIdDocument'] to see the possible values for this operation
     *
     * @throws \Irisnet\API\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Irisnet\API\Client\Model\CheckResult|\Irisnet\API\Client\Model\ApiNotice, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkIdDocumentWithHttpInfo($configId, $documentCheckRequestData, string $contentType = self::contentTypes['checkIdDocument'][0])
    {
        $request = $this->checkIdDocumentRequest($configId, $documentCheckRequestData, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    return $this->handleResponseWithDataType(
                        '\Irisnet\API\Client\Model\CheckResult',
                        $request,
                        $response,
                    );
                case 402:
                    return $this->handleResponseWithDataType(
                        '\Irisnet\API\Client\Model\ApiNotice',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Irisnet\API\Client\Model\CheckResult',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Irisnet\API\Client\Model\CheckResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Irisnet\API\Client\Model\ApiNotice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation checkIdDocumentAsync
     *
     * Check an id document with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  \Irisnet\API\Client\Model\DocumentCheckRequestData $documentCheckRequestData The DocumentCheckRequestData containing data needed for the id document check. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkIdDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkIdDocumentAsync($configId, $documentCheckRequestData, string $contentType = self::contentTypes['checkIdDocument'][0])
    {
        return $this->checkIdDocumentAsyncWithHttpInfo($configId, $documentCheckRequestData, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkIdDocumentAsyncWithHttpInfo
     *
     * Check an id document with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  \Irisnet\API\Client\Model\DocumentCheckRequestData $documentCheckRequestData The DocumentCheckRequestData containing data needed for the id document check. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkIdDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkIdDocumentAsyncWithHttpInfo($configId, $documentCheckRequestData, string $contentType = self::contentTypes['checkIdDocument'][0])
    {
        $returnType = '\Irisnet\API\Client\Model\CheckResult';
        $request = $this->checkIdDocumentRequest($configId, $documentCheckRequestData, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkIdDocument'
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  \Irisnet\API\Client\Model\DocumentCheckRequestData $documentCheckRequestData The DocumentCheckRequestData containing data needed for the id document check. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkIdDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function checkIdDocumentRequest($configId, $documentCheckRequestData, string $contentType = self::contentTypes['checkIdDocument'][0])
    {

        // verify the required parameter 'configId' is set
        if ($configId === null || (is_array($configId) && count($configId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $configId when calling checkIdDocument'
            );
        }

        // verify the required parameter 'documentCheckRequestData' is set
        if ($documentCheckRequestData === null || (is_array($documentCheckRequestData) && count($documentCheckRequestData) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $documentCheckRequestData when calling checkIdDocument'
            );
        }


        $resourcePath = '/v2/check-id-document/{configId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($configId !== null) {
            $resourcePath = str_replace(
                '{' . 'configId' . '}',
                ObjectSerializer::toPathValue($configId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($documentCheckRequestData)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($documentCheckRequestData));
            } else {
                $httpBody = $documentCheckRequestData;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('LICENSE-KEY');
        if ($apiKey !== null) {
            $headers['LICENSE-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation checkImage
     *
     * Check an image with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  string|null $url &lt;s&gt;The url to the image that needs to be checked.&lt;/s&gt; Deprecated: Use request body instead. &lt;b&gt;This parameter will be removed in future releases.&lt;/b&gt; (optional) (deprecated)
     * @param  int|null $detail Set the detail level of the response.  * _1_ - The response only contains the _Summary_ and possibly the _Encoded_ schemas for basic information&#39;s (better API performance). * _2_ - Additionally lists all broken rules (_BrokenRule_ schema) according to the configuration parameters that were requested. * _3_ - Also shows detections (e.g. _BaseDetection_ schema) that contains extended features to each found object. (optional, default to 1)
     * @param  bool|null $imageEncode Specifies whether or not to draw an output image that will be delivered in the response body as base64 encoded string. The _Encoded_ schema will be available in the response. (optional, default to false)
     * @param  \Irisnet\API\Client\Model\Data|null $data The http(s) url or base64 encoded body uri of the image that needs to be checked. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkImage'] to see the possible values for this operation
     *
     * @throws \Irisnet\API\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Irisnet\API\Client\Model\CheckResult|\Irisnet\API\Client\Model\ApiNotice|\Irisnet\API\Client\Model\ApiNotice
     */
    public function checkImage($configId, $url = null, $detail = 1, $imageEncode = false, $data = null, string $contentType = self::contentTypes['checkImage'][0])
    {
        list($response) = $this->checkImageWithHttpInfo($configId, $url, $detail, $imageEncode, $data, $contentType);
        return $response;
    }

    /**
     * Operation checkImageWithHttpInfo
     *
     * Check an image with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  string|null $url &lt;s&gt;The url to the image that needs to be checked.&lt;/s&gt; Deprecated: Use request body instead. &lt;b&gt;This parameter will be removed in future releases.&lt;/b&gt; (optional) (deprecated)
     * @param  int|null $detail Set the detail level of the response.  * _1_ - The response only contains the _Summary_ and possibly the _Encoded_ schemas for basic information&#39;s (better API performance). * _2_ - Additionally lists all broken rules (_BrokenRule_ schema) according to the configuration parameters that were requested. * _3_ - Also shows detections (e.g. _BaseDetection_ schema) that contains extended features to each found object. (optional, default to 1)
     * @param  bool|null $imageEncode Specifies whether or not to draw an output image that will be delivered in the response body as base64 encoded string. The _Encoded_ schema will be available in the response. (optional, default to false)
     * @param  \Irisnet\API\Client\Model\Data|null $data The http(s) url or base64 encoded body uri of the image that needs to be checked. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkImage'] to see the possible values for this operation
     *
     * @throws \Irisnet\API\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Irisnet\API\Client\Model\CheckResult|\Irisnet\API\Client\Model\ApiNotice|\Irisnet\API\Client\Model\ApiNotice, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkImageWithHttpInfo($configId, $url = null, $detail = 1, $imageEncode = false, $data = null, string $contentType = self::contentTypes['checkImage'][0])
    {
        $request = $this->checkImageRequest($configId, $url, $detail, $imageEncode, $data, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Irisnet\API\Client\Model\CheckResult',
                        $request,
                        $response,
                    );
                case 402:
                    return $this->handleResponseWithDataType(
                        '\Irisnet\API\Client\Model\ApiNotice',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Irisnet\API\Client\Model\ApiNotice',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Irisnet\API\Client\Model\CheckResult',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Irisnet\API\Client\Model\CheckResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Irisnet\API\Client\Model\ApiNotice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Irisnet\API\Client\Model\ApiNotice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation checkImageAsync
     *
     * Check an image with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  string|null $url &lt;s&gt;The url to the image that needs to be checked.&lt;/s&gt; Deprecated: Use request body instead. &lt;b&gt;This parameter will be removed in future releases.&lt;/b&gt; (optional) (deprecated)
     * @param  int|null $detail Set the detail level of the response.  * _1_ - The response only contains the _Summary_ and possibly the _Encoded_ schemas for basic information&#39;s (better API performance). * _2_ - Additionally lists all broken rules (_BrokenRule_ schema) according to the configuration parameters that were requested. * _3_ - Also shows detections (e.g. _BaseDetection_ schema) that contains extended features to each found object. (optional, default to 1)
     * @param  bool|null $imageEncode Specifies whether or not to draw an output image that will be delivered in the response body as base64 encoded string. The _Encoded_ schema will be available in the response. (optional, default to false)
     * @param  \Irisnet\API\Client\Model\Data|null $data The http(s) url or base64 encoded body uri of the image that needs to be checked. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkImageAsync($configId, $url = null, $detail = 1, $imageEncode = false, $data = null, string $contentType = self::contentTypes['checkImage'][0])
    {
        return $this->checkImageAsyncWithHttpInfo($configId, $url, $detail, $imageEncode, $data, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkImageAsyncWithHttpInfo
     *
     * Check an image with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  string|null $url &lt;s&gt;The url to the image that needs to be checked.&lt;/s&gt; Deprecated: Use request body instead. &lt;b&gt;This parameter will be removed in future releases.&lt;/b&gt; (optional) (deprecated)
     * @param  int|null $detail Set the detail level of the response.  * _1_ - The response only contains the _Summary_ and possibly the _Encoded_ schemas for basic information&#39;s (better API performance). * _2_ - Additionally lists all broken rules (_BrokenRule_ schema) according to the configuration parameters that were requested. * _3_ - Also shows detections (e.g. _BaseDetection_ schema) that contains extended features to each found object. (optional, default to 1)
     * @param  bool|null $imageEncode Specifies whether or not to draw an output image that will be delivered in the response body as base64 encoded string. The _Encoded_ schema will be available in the response. (optional, default to false)
     * @param  \Irisnet\API\Client\Model\Data|null $data The http(s) url or base64 encoded body uri of the image that needs to be checked. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkImageAsyncWithHttpInfo($configId, $url = null, $detail = 1, $imageEncode = false, $data = null, string $contentType = self::contentTypes['checkImage'][0])
    {
        $returnType = '\Irisnet\API\Client\Model\CheckResult';
        $request = $this->checkImageRequest($configId, $url, $detail, $imageEncode, $data, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkImage'
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  string|null $url &lt;s&gt;The url to the image that needs to be checked.&lt;/s&gt; Deprecated: Use request body instead. &lt;b&gt;This parameter will be removed in future releases.&lt;/b&gt; (optional) (deprecated)
     * @param  int|null $detail Set the detail level of the response.  * _1_ - The response only contains the _Summary_ and possibly the _Encoded_ schemas for basic information&#39;s (better API performance). * _2_ - Additionally lists all broken rules (_BrokenRule_ schema) according to the configuration parameters that were requested. * _3_ - Also shows detections (e.g. _BaseDetection_ schema) that contains extended features to each found object. (optional, default to 1)
     * @param  bool|null $imageEncode Specifies whether or not to draw an output image that will be delivered in the response body as base64 encoded string. The _Encoded_ schema will be available in the response. (optional, default to false)
     * @param  \Irisnet\API\Client\Model\Data|null $data The http(s) url or base64 encoded body uri of the image that needs to be checked. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function checkImageRequest($configId, $url = null, $detail = 1, $imageEncode = false, $data = null, string $contentType = self::contentTypes['checkImage'][0])
    {

        // verify the required parameter 'configId' is set
        if ($configId === null || (is_array($configId) && count($configId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $configId when calling checkImage'
            );
        }


        if ($detail !== null && $detail > 3) {
            throw new \InvalidArgumentException('invalid value for "$detail" when calling AICheckOperationsApi.checkImage, must be smaller than or equal to 3.');
        }
        if ($detail !== null && $detail < 0) {
            throw new \InvalidArgumentException('invalid value for "$detail" when calling AICheckOperationsApi.checkImage, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/v2/check-image/{configId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url,
            'url', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $detail,
            'detail', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $imageEncode,
            'imageEncode', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($configId !== null) {
            $resourcePath = str_replace(
                '{' . 'configId' . '}',
                ObjectSerializer::toPathValue($configId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($data)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($data));
            } else {
                $httpBody = $data;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('LICENSE-KEY');
        if ($apiKey !== null) {
            $headers['LICENSE-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation checkPoaDocument
     *
     * Perform a proof of address check with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  \Irisnet\API\Client\Model\PoaCheckRequestData $poaCheckRequestData The PoaCheckRequestData containing data needed for the proof of address check. The DocumentType in the request data must be either &#39;utility_bill&#39; or &#39;bank_statement&#39;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkPoaDocument'] to see the possible values for this operation
     *
     * @throws \Irisnet\API\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Irisnet\API\Client\Model\CheckResult|\Irisnet\API\Client\Model\ApiNotice
     */
    public function checkPoaDocument($configId, $poaCheckRequestData, string $contentType = self::contentTypes['checkPoaDocument'][0])
    {
        list($response) = $this->checkPoaDocumentWithHttpInfo($configId, $poaCheckRequestData, $contentType);
        return $response;
    }

    /**
     * Operation checkPoaDocumentWithHttpInfo
     *
     * Perform a proof of address check with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  \Irisnet\API\Client\Model\PoaCheckRequestData $poaCheckRequestData The PoaCheckRequestData containing data needed for the proof of address check. The DocumentType in the request data must be either &#39;utility_bill&#39; or &#39;bank_statement&#39;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkPoaDocument'] to see the possible values for this operation
     *
     * @throws \Irisnet\API\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Irisnet\API\Client\Model\CheckResult|\Irisnet\API\Client\Model\ApiNotice, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkPoaDocumentWithHttpInfo($configId, $poaCheckRequestData, string $contentType = self::contentTypes['checkPoaDocument'][0])
    {
        $request = $this->checkPoaDocumentRequest($configId, $poaCheckRequestData, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    return $this->handleResponseWithDataType(
                        '\Irisnet\API\Client\Model\CheckResult',
                        $request,
                        $response,
                    );
                case 402:
                    return $this->handleResponseWithDataType(
                        '\Irisnet\API\Client\Model\ApiNotice',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Irisnet\API\Client\Model\CheckResult',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Irisnet\API\Client\Model\CheckResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Irisnet\API\Client\Model\ApiNotice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation checkPoaDocumentAsync
     *
     * Perform a proof of address check with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  \Irisnet\API\Client\Model\PoaCheckRequestData $poaCheckRequestData The PoaCheckRequestData containing data needed for the proof of address check. The DocumentType in the request data must be either &#39;utility_bill&#39; or &#39;bank_statement&#39;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkPoaDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkPoaDocumentAsync($configId, $poaCheckRequestData, string $contentType = self::contentTypes['checkPoaDocument'][0])
    {
        return $this->checkPoaDocumentAsyncWithHttpInfo($configId, $poaCheckRequestData, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkPoaDocumentAsyncWithHttpInfo
     *
     * Perform a proof of address check with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  \Irisnet\API\Client\Model\PoaCheckRequestData $poaCheckRequestData The PoaCheckRequestData containing data needed for the proof of address check. The DocumentType in the request data must be either &#39;utility_bill&#39; or &#39;bank_statement&#39;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkPoaDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkPoaDocumentAsyncWithHttpInfo($configId, $poaCheckRequestData, string $contentType = self::contentTypes['checkPoaDocument'][0])
    {
        $returnType = '\Irisnet\API\Client\Model\CheckResult';
        $request = $this->checkPoaDocumentRequest($configId, $poaCheckRequestData, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkPoaDocument'
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  \Irisnet\API\Client\Model\PoaCheckRequestData $poaCheckRequestData The PoaCheckRequestData containing data needed for the proof of address check. The DocumentType in the request data must be either &#39;utility_bill&#39; or &#39;bank_statement&#39;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkPoaDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function checkPoaDocumentRequest($configId, $poaCheckRequestData, string $contentType = self::contentTypes['checkPoaDocument'][0])
    {

        // verify the required parameter 'configId' is set
        if ($configId === null || (is_array($configId) && count($configId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $configId when calling checkPoaDocument'
            );
        }

        // verify the required parameter 'poaCheckRequestData' is set
        if ($poaCheckRequestData === null || (is_array($poaCheckRequestData) && count($poaCheckRequestData) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $poaCheckRequestData when calling checkPoaDocument'
            );
        }


        $resourcePath = '/v2/check-poa-document/{configId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($configId !== null) {
            $resourcePath = str_replace(
                '{' . 'configId' . '}',
                ObjectSerializer::toPathValue($configId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($poaCheckRequestData)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($poaCheckRequestData));
            } else {
                $httpBody = $poaCheckRequestData;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('LICENSE-KEY');
        if ($apiKey !== null) {
            $headers['LICENSE-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation checkStream
     *
     * Check a stream with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  string $inUrl The URL of the video stream that the AI should check. (required)
     * @param  string|null $outUrl The URL of where the AI should send the encoded stream. (optional)
     * @param  int|null $cycleLength Determine how often (value in milliseconds) the the AI should give a feedback. (optional, default to 500)
     * @param  int|null $checkRate The milliseconds between each AI check. E.g. The AI will check 1 frame per second when checkRate is set to &#39;1000&#39;. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkStream'] to see the possible values for this operation
     *
     * @throws \Irisnet\API\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Irisnet\API\Client\Model\CheckResult[]|\Irisnet\API\Client\Model\ApiNotice|\Irisnet\API\Client\Model\ApiNotice
     */
    public function checkStream($configId, $inUrl, $outUrl = null, $cycleLength = 500, $checkRate = 0, string $contentType = self::contentTypes['checkStream'][0])
    {
        list($response) = $this->checkStreamWithHttpInfo($configId, $inUrl, $outUrl, $cycleLength, $checkRate, $contentType);
        return $response;
    }

    /**
     * Operation checkStreamWithHttpInfo
     *
     * Check a stream with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  string $inUrl The URL of the video stream that the AI should check. (required)
     * @param  string|null $outUrl The URL of where the AI should send the encoded stream. (optional)
     * @param  int|null $cycleLength Determine how often (value in milliseconds) the the AI should give a feedback. (optional, default to 500)
     * @param  int|null $checkRate The milliseconds between each AI check. E.g. The AI will check 1 frame per second when checkRate is set to &#39;1000&#39;. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkStream'] to see the possible values for this operation
     *
     * @throws \Irisnet\API\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Irisnet\API\Client\Model\CheckResult[]|\Irisnet\API\Client\Model\ApiNotice|\Irisnet\API\Client\Model\ApiNotice, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkStreamWithHttpInfo($configId, $inUrl, $outUrl = null, $cycleLength = 500, $checkRate = 0, string $contentType = self::contentTypes['checkStream'][0])
    {
        $request = $this->checkStreamRequest($configId, $inUrl, $outUrl, $cycleLength, $checkRate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Irisnet\API\Client\Model\CheckResult[]',
                        $request,
                        $response,
                    );
                case 402:
                    return $this->handleResponseWithDataType(
                        '\Irisnet\API\Client\Model\ApiNotice',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Irisnet\API\Client\Model\ApiNotice',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Irisnet\API\Client\Model\CheckResult[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Irisnet\API\Client\Model\CheckResult[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Irisnet\API\Client\Model\ApiNotice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Irisnet\API\Client\Model\ApiNotice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation checkStreamAsync
     *
     * Check a stream with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  string $inUrl The URL of the video stream that the AI should check. (required)
     * @param  string|null $outUrl The URL of where the AI should send the encoded stream. (optional)
     * @param  int|null $cycleLength Determine how often (value in milliseconds) the the AI should give a feedback. (optional, default to 500)
     * @param  int|null $checkRate The milliseconds between each AI check. E.g. The AI will check 1 frame per second when checkRate is set to &#39;1000&#39;. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkStream'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkStreamAsync($configId, $inUrl, $outUrl = null, $cycleLength = 500, $checkRate = 0, string $contentType = self::contentTypes['checkStream'][0])
    {
        return $this->checkStreamAsyncWithHttpInfo($configId, $inUrl, $outUrl, $cycleLength, $checkRate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkStreamAsyncWithHttpInfo
     *
     * Check a stream with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  string $inUrl The URL of the video stream that the AI should check. (required)
     * @param  string|null $outUrl The URL of where the AI should send the encoded stream. (optional)
     * @param  int|null $cycleLength Determine how often (value in milliseconds) the the AI should give a feedback. (optional, default to 500)
     * @param  int|null $checkRate The milliseconds between each AI check. E.g. The AI will check 1 frame per second when checkRate is set to &#39;1000&#39;. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkStream'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkStreamAsyncWithHttpInfo($configId, $inUrl, $outUrl = null, $cycleLength = 500, $checkRate = 0, string $contentType = self::contentTypes['checkStream'][0])
    {
        $returnType = '\Irisnet\API\Client\Model\CheckResult[]';
        $request = $this->checkStreamRequest($configId, $inUrl, $outUrl, $cycleLength, $checkRate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkStream'
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  string $inUrl The URL of the video stream that the AI should check. (required)
     * @param  string|null $outUrl The URL of where the AI should send the encoded stream. (optional)
     * @param  int|null $cycleLength Determine how often (value in milliseconds) the the AI should give a feedback. (optional, default to 500)
     * @param  int|null $checkRate The milliseconds between each AI check. E.g. The AI will check 1 frame per second when checkRate is set to &#39;1000&#39;. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkStream'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function checkStreamRequest($configId, $inUrl, $outUrl = null, $cycleLength = 500, $checkRate = 0, string $contentType = self::contentTypes['checkStream'][0])
    {

        // verify the required parameter 'configId' is set
        if ($configId === null || (is_array($configId) && count($configId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $configId when calling checkStream'
            );
        }

        // verify the required parameter 'inUrl' is set
        if ($inUrl === null || (is_array($inUrl) && count($inUrl) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inUrl when calling checkStream'
            );
        }


        if ($cycleLength !== null && $cycleLength < 100) {
            throw new \InvalidArgumentException('invalid value for "$cycleLength" when calling AICheckOperationsApi.checkStream, must be bigger than or equal to 100.');
        }
        
        if ($checkRate !== null && $checkRate < 0) {
            throw new \InvalidArgumentException('invalid value for "$checkRate" when calling AICheckOperationsApi.checkStream, must be bigger than or equal to 0.');
        }
        

        $resourcePath = '/v2/check-stream/{configId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $inUrl,
            'inUrl', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $outUrl,
            'outUrl', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cycleLength,
            'cycleLength', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $checkRate,
            'checkRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($configId !== null) {
            $resourcePath = str_replace(
                '{' . 'configId' . '}',
                ObjectSerializer::toPathValue($configId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/x-ndjson', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('LICENSE-KEY');
        if ($apiKey !== null) {
            $headers['LICENSE-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation checkText
     *
     * Check a text with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  \Irisnet\API\Client\Model\Data $data The text that needs to be checked. (required)
     * @param  int|null $detail Set the detail level of the response.  * _1_ - The response only contains the _Summary_ and possibly the _Encoded_ schemas for basic information&#39;s (better API performance). * _2_ - Additionally lists all broken rules (_BrokenRule_ schema) according to the configuration parameters that were requested. * _3_ - Also shows detections (e.g. _BaseDetection_ schema) that contains extended features to each found object. (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkText'] to see the possible values for this operation
     *
     * @throws \Irisnet\API\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Irisnet\API\Client\Model\CheckResult|\Irisnet\API\Client\Model\ApiNotice|\Irisnet\API\Client\Model\ApiNotice
     */
    public function checkText($configId, $data, $detail = 1, string $contentType = self::contentTypes['checkText'][0])
    {
        list($response) = $this->checkTextWithHttpInfo($configId, $data, $detail, $contentType);
        return $response;
    }

    /**
     * Operation checkTextWithHttpInfo
     *
     * Check a text with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  \Irisnet\API\Client\Model\Data $data The text that needs to be checked. (required)
     * @param  int|null $detail Set the detail level of the response.  * _1_ - The response only contains the _Summary_ and possibly the _Encoded_ schemas for basic information&#39;s (better API performance). * _2_ - Additionally lists all broken rules (_BrokenRule_ schema) according to the configuration parameters that were requested. * _3_ - Also shows detections (e.g. _BaseDetection_ schema) that contains extended features to each found object. (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkText'] to see the possible values for this operation
     *
     * @throws \Irisnet\API\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Irisnet\API\Client\Model\CheckResult|\Irisnet\API\Client\Model\ApiNotice|\Irisnet\API\Client\Model\ApiNotice, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkTextWithHttpInfo($configId, $data, $detail = 1, string $contentType = self::contentTypes['checkText'][0])
    {
        $request = $this->checkTextRequest($configId, $data, $detail, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Irisnet\API\Client\Model\CheckResult',
                        $request,
                        $response,
                    );
                case 402:
                    return $this->handleResponseWithDataType(
                        '\Irisnet\API\Client\Model\ApiNotice',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\Irisnet\API\Client\Model\ApiNotice',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Irisnet\API\Client\Model\CheckResult',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Irisnet\API\Client\Model\CheckResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Irisnet\API\Client\Model\ApiNotice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Irisnet\API\Client\Model\ApiNotice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation checkTextAsync
     *
     * Check a text with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  \Irisnet\API\Client\Model\Data $data The text that needs to be checked. (required)
     * @param  int|null $detail Set the detail level of the response.  * _1_ - The response only contains the _Summary_ and possibly the _Encoded_ schemas for basic information&#39;s (better API performance). * _2_ - Additionally lists all broken rules (_BrokenRule_ schema) according to the configuration parameters that were requested. * _3_ - Also shows detections (e.g. _BaseDetection_ schema) that contains extended features to each found object. (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkText'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkTextAsync($configId, $data, $detail = 1, string $contentType = self::contentTypes['checkText'][0])
    {
        return $this->checkTextAsyncWithHttpInfo($configId, $data, $detail, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkTextAsyncWithHttpInfo
     *
     * Check a text with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  \Irisnet\API\Client\Model\Data $data The text that needs to be checked. (required)
     * @param  int|null $detail Set the detail level of the response.  * _1_ - The response only contains the _Summary_ and possibly the _Encoded_ schemas for basic information&#39;s (better API performance). * _2_ - Additionally lists all broken rules (_BrokenRule_ schema) according to the configuration parameters that were requested. * _3_ - Also shows detections (e.g. _BaseDetection_ schema) that contains extended features to each found object. (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkText'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkTextAsyncWithHttpInfo($configId, $data, $detail = 1, string $contentType = self::contentTypes['checkText'][0])
    {
        $returnType = '\Irisnet\API\Client\Model\CheckResult';
        $request = $this->checkTextRequest($configId, $data, $detail, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkText'
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  \Irisnet\API\Client\Model\Data $data The text that needs to be checked. (required)
     * @param  int|null $detail Set the detail level of the response.  * _1_ - The response only contains the _Summary_ and possibly the _Encoded_ schemas for basic information&#39;s (better API performance). * _2_ - Additionally lists all broken rules (_BrokenRule_ schema) according to the configuration parameters that were requested. * _3_ - Also shows detections (e.g. _BaseDetection_ schema) that contains extended features to each found object. (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkText'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function checkTextRequest($configId, $data, $detail = 1, string $contentType = self::contentTypes['checkText'][0])
    {

        // verify the required parameter 'configId' is set
        if ($configId === null || (is_array($configId) && count($configId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $configId when calling checkText'
            );
        }

        // verify the required parameter 'data' is set
        if ($data === null || (is_array($data) && count($data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data when calling checkText'
            );
        }

        if ($detail !== null && $detail > 3) {
            throw new \InvalidArgumentException('invalid value for "$detail" when calling AICheckOperationsApi.checkText, must be smaller than or equal to 3.');
        }
        if ($detail !== null && $detail < 0) {
            throw new \InvalidArgumentException('invalid value for "$detail" when calling AICheckOperationsApi.checkText, must be bigger than or equal to 0.');
        }
        

        $resourcePath = '/v2/check-text/{configId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $detail,
            'detail', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($configId !== null) {
            $resourcePath = str_replace(
                '{' . 'configId' . '}',
                ObjectSerializer::toPathValue($configId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($data)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($data));
            } else {
                $httpBody = $data;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('LICENSE-KEY');
        if ($apiKey !== null) {
            $headers['LICENSE-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation checkVideo
     *
     * Check a video with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  string $url The url to the video that needs to be checked. (required)
     * @param  \Irisnet\API\Client\Model\Callback $callback callback (required)
     * @param  int|null $detail Set the detail level of the response.  * _1_ - The response only contains the _Summary_ and possibly the _Encoded_ schemas for basic information&#39;s (better API performance). * _2_ - Additionally lists all broken rules (_BrokenRule_ schema) according to the configuration parameters that were requested. * _3_ - Also shows events (_Event_ schema) that contains extended features to each found object. (optional, default to 1)
     * @param  bool|null $imageEncode Specifies whether or not to draw an output video that can be downloaded afterwards. The output video format will be MP4 containing H.264 encoding independent of the input format. The _Encoded_ schema will be available in the response. (optional, default to false)
     * @param  int|null $checkRate The milliseconds between each AI check. E.g. The AI will check 1 frame per second when checkRate is set to &#39;1000&#39;. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkVideo'] to see the possible values for this operation
     *
     * @throws \Irisnet\API\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function checkVideo($configId, $url, $callback, $detail = 1, $imageEncode = false, $checkRate = 0, string $contentType = self::contentTypes['checkVideo'][0])
    {
        $this->checkVideoWithHttpInfo($configId, $url, $callback, $detail, $imageEncode, $checkRate, $contentType);
    }

    /**
     * Operation checkVideoWithHttpInfo
     *
     * Check a video with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  string $url The url to the video that needs to be checked. (required)
     * @param  \Irisnet\API\Client\Model\Callback $callback (required)
     * @param  int|null $detail Set the detail level of the response.  * _1_ - The response only contains the _Summary_ and possibly the _Encoded_ schemas for basic information&#39;s (better API performance). * _2_ - Additionally lists all broken rules (_BrokenRule_ schema) according to the configuration parameters that were requested. * _3_ - Also shows events (_Event_ schema) that contains extended features to each found object. (optional, default to 1)
     * @param  bool|null $imageEncode Specifies whether or not to draw an output video that can be downloaded afterwards. The output video format will be MP4 containing H.264 encoding independent of the input format. The _Encoded_ schema will be available in the response. (optional, default to false)
     * @param  int|null $checkRate The milliseconds between each AI check. E.g. The AI will check 1 frame per second when checkRate is set to &#39;1000&#39;. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkVideo'] to see the possible values for this operation
     *
     * @throws \Irisnet\API\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkVideoWithHttpInfo($configId, $url, $callback, $detail = 1, $imageEncode = false, $checkRate = 0, string $contentType = self::contentTypes['checkVideo'][0])
    {
        $request = $this->checkVideoRequest($configId, $url, $callback, $detail, $imageEncode, $checkRate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Irisnet\API\Client\Model\ApiNotice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Irisnet\API\Client\Model\ApiNotice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation checkVideoAsync
     *
     * Check a video with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  string $url The url to the video that needs to be checked. (required)
     * @param  \Irisnet\API\Client\Model\Callback $callback (required)
     * @param  int|null $detail Set the detail level of the response.  * _1_ - The response only contains the _Summary_ and possibly the _Encoded_ schemas for basic information&#39;s (better API performance). * _2_ - Additionally lists all broken rules (_BrokenRule_ schema) according to the configuration parameters that were requested. * _3_ - Also shows events (_Event_ schema) that contains extended features to each found object. (optional, default to 1)
     * @param  bool|null $imageEncode Specifies whether or not to draw an output video that can be downloaded afterwards. The output video format will be MP4 containing H.264 encoding independent of the input format. The _Encoded_ schema will be available in the response. (optional, default to false)
     * @param  int|null $checkRate The milliseconds between each AI check. E.g. The AI will check 1 frame per second when checkRate is set to &#39;1000&#39;. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkVideo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkVideoAsync($configId, $url, $callback, $detail = 1, $imageEncode = false, $checkRate = 0, string $contentType = self::contentTypes['checkVideo'][0])
    {
        return $this->checkVideoAsyncWithHttpInfo($configId, $url, $callback, $detail, $imageEncode, $checkRate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkVideoAsyncWithHttpInfo
     *
     * Check a video with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  string $url The url to the video that needs to be checked. (required)
     * @param  \Irisnet\API\Client\Model\Callback $callback (required)
     * @param  int|null $detail Set the detail level of the response.  * _1_ - The response only contains the _Summary_ and possibly the _Encoded_ schemas for basic information&#39;s (better API performance). * _2_ - Additionally lists all broken rules (_BrokenRule_ schema) according to the configuration parameters that were requested. * _3_ - Also shows events (_Event_ schema) that contains extended features to each found object. (optional, default to 1)
     * @param  bool|null $imageEncode Specifies whether or not to draw an output video that can be downloaded afterwards. The output video format will be MP4 containing H.264 encoding independent of the input format. The _Encoded_ schema will be available in the response. (optional, default to false)
     * @param  int|null $checkRate The milliseconds between each AI check. E.g. The AI will check 1 frame per second when checkRate is set to &#39;1000&#39;. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkVideo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkVideoAsyncWithHttpInfo($configId, $url, $callback, $detail = 1, $imageEncode = false, $checkRate = 0, string $contentType = self::contentTypes['checkVideo'][0])
    {
        $returnType = '';
        $request = $this->checkVideoRequest($configId, $url, $callback, $detail, $imageEncode, $checkRate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkVideo'
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  string $url The url to the video that needs to be checked. (required)
     * @param  \Irisnet\API\Client\Model\Callback $callback (required)
     * @param  int|null $detail Set the detail level of the response.  * _1_ - The response only contains the _Summary_ and possibly the _Encoded_ schemas for basic information&#39;s (better API performance). * _2_ - Additionally lists all broken rules (_BrokenRule_ schema) according to the configuration parameters that were requested. * _3_ - Also shows events (_Event_ schema) that contains extended features to each found object. (optional, default to 1)
     * @param  bool|null $imageEncode Specifies whether or not to draw an output video that can be downloaded afterwards. The output video format will be MP4 containing H.264 encoding independent of the input format. The _Encoded_ schema will be available in the response. (optional, default to false)
     * @param  int|null $checkRate The milliseconds between each AI check. E.g. The AI will check 1 frame per second when checkRate is set to &#39;1000&#39;. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkVideo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function checkVideoRequest($configId, $url, $callback, $detail = 1, $imageEncode = false, $checkRate = 0, string $contentType = self::contentTypes['checkVideo'][0])
    {

        // verify the required parameter 'configId' is set
        if ($configId === null || (is_array($configId) && count($configId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $configId when calling checkVideo'
            );
        }

        // verify the required parameter 'url' is set
        if ($url === null || (is_array($url) && count($url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $url when calling checkVideo'
            );
        }

        // verify the required parameter 'callback' is set
        if ($callback === null || (is_array($callback) && count($callback) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $callback when calling checkVideo'
            );
        }

        if ($detail !== null && $detail > 3) {
            throw new \InvalidArgumentException('invalid value for "$detail" when calling AICheckOperationsApi.checkVideo, must be smaller than or equal to 3.');
        }
        if ($detail !== null && $detail < 0) {
            throw new \InvalidArgumentException('invalid value for "$detail" when calling AICheckOperationsApi.checkVideo, must be bigger than or equal to 0.');
        }
        

        if ($checkRate !== null && $checkRate < 0) {
            throw new \InvalidArgumentException('invalid value for "$checkRate" when calling AICheckOperationsApi.checkVideo, must be bigger than or equal to 0.');
        }
        

        $resourcePath = '/v2/check-video/{configId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url,
            'url', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $detail,
            'detail', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $imageEncode,
            'imageEncode', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $checkRate,
            'checkRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($configId !== null) {
            $resourcePath = str_replace(
                '{' . 'configId' . '}',
                ObjectSerializer::toPathValue($configId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($callback)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($callback));
            } else {
                $httpBody = $callback;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('LICENSE-KEY');
        if ($apiKey !== null) {
            $headers['LICENSE-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation faceAuthentication
     *
     * Perform a face authentication for a given selfie with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  \Irisnet\API\Client\Model\BiometricCheckRequestData $biometricCheckRequestData The BiometricCheckRequestData containing data needed for the face authentication. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['faceAuthentication'] to see the possible values for this operation
     *
     * @throws \Irisnet\API\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Irisnet\API\Client\Model\CheckResult|\Irisnet\API\Client\Model\ApiNotice
     */
    public function faceAuthentication($configId, $biometricCheckRequestData, string $contentType = self::contentTypes['faceAuthentication'][0])
    {
        list($response) = $this->faceAuthenticationWithHttpInfo($configId, $biometricCheckRequestData, $contentType);
        return $response;
    }

    /**
     * Operation faceAuthenticationWithHttpInfo
     *
     * Perform a face authentication for a given selfie with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  \Irisnet\API\Client\Model\BiometricCheckRequestData $biometricCheckRequestData The BiometricCheckRequestData containing data needed for the face authentication. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['faceAuthentication'] to see the possible values for this operation
     *
     * @throws \Irisnet\API\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Irisnet\API\Client\Model\CheckResult|\Irisnet\API\Client\Model\ApiNotice, HTTP status code, HTTP response headers (array of strings)
     */
    public function faceAuthenticationWithHttpInfo($configId, $biometricCheckRequestData, string $contentType = self::contentTypes['faceAuthentication'][0])
    {
        $request = $this->faceAuthenticationRequest($configId, $biometricCheckRequestData, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    return $this->handleResponseWithDataType(
                        '\Irisnet\API\Client\Model\CheckResult',
                        $request,
                        $response,
                    );
                case 402:
                    return $this->handleResponseWithDataType(
                        '\Irisnet\API\Client\Model\ApiNotice',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Irisnet\API\Client\Model\CheckResult',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Irisnet\API\Client\Model\CheckResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Irisnet\API\Client\Model\ApiNotice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation faceAuthenticationAsync
     *
     * Perform a face authentication for a given selfie with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  \Irisnet\API\Client\Model\BiometricCheckRequestData $biometricCheckRequestData The BiometricCheckRequestData containing data needed for the face authentication. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['faceAuthentication'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function faceAuthenticationAsync($configId, $biometricCheckRequestData, string $contentType = self::contentTypes['faceAuthentication'][0])
    {
        return $this->faceAuthenticationAsyncWithHttpInfo($configId, $biometricCheckRequestData, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation faceAuthenticationAsyncWithHttpInfo
     *
     * Perform a face authentication for a given selfie with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  \Irisnet\API\Client\Model\BiometricCheckRequestData $biometricCheckRequestData The BiometricCheckRequestData containing data needed for the face authentication. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['faceAuthentication'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function faceAuthenticationAsyncWithHttpInfo($configId, $biometricCheckRequestData, string $contentType = self::contentTypes['faceAuthentication'][0])
    {
        $returnType = '\Irisnet\API\Client\Model\CheckResult';
        $request = $this->faceAuthenticationRequest($configId, $biometricCheckRequestData, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'faceAuthentication'
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  \Irisnet\API\Client\Model\BiometricCheckRequestData $biometricCheckRequestData The BiometricCheckRequestData containing data needed for the face authentication. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['faceAuthentication'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function faceAuthenticationRequest($configId, $biometricCheckRequestData, string $contentType = self::contentTypes['faceAuthentication'][0])
    {

        // verify the required parameter 'configId' is set
        if ($configId === null || (is_array($configId) && count($configId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $configId when calling faceAuthentication'
            );
        }

        // verify the required parameter 'biometricCheckRequestData' is set
        if ($biometricCheckRequestData === null || (is_array($biometricCheckRequestData) && count($biometricCheckRequestData) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $biometricCheckRequestData when calling faceAuthentication'
            );
        }


        $resourcePath = '/v2/face-authentication/{configId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($configId !== null) {
            $resourcePath = str_replace(
                '{' . 'configId' . '}',
                ObjectSerializer::toPathValue($configId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($biometricCheckRequestData)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($biometricCheckRequestData));
            } else {
                $httpBody = $biometricCheckRequestData;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('LICENSE-KEY');
        if ($apiKey !== null) {
            $headers['LICENSE-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation liveDocumentCheck
     *
     * Start a guided live id document check with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  \Irisnet\API\Client\Model\LiveDocumentCheckRequestData $liveDocumentCheckRequestData The LiveDocumentCheckRequestData containing data needed for the live id document check. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['liveDocumentCheck'] to see the possible values for this operation
     *
     * @throws \Irisnet\API\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Irisnet\API\Client\Model\LiveDocumentCheckResponseData|\Irisnet\API\Client\Model\ApiNotice
     */
    public function liveDocumentCheck($configId, $liveDocumentCheckRequestData, string $contentType = self::contentTypes['liveDocumentCheck'][0])
    {
        list($response) = $this->liveDocumentCheckWithHttpInfo($configId, $liveDocumentCheckRequestData, $contentType);
        return $response;
    }

    /**
     * Operation liveDocumentCheckWithHttpInfo
     *
     * Start a guided live id document check with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  \Irisnet\API\Client\Model\LiveDocumentCheckRequestData $liveDocumentCheckRequestData The LiveDocumentCheckRequestData containing data needed for the live id document check. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['liveDocumentCheck'] to see the possible values for this operation
     *
     * @throws \Irisnet\API\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Irisnet\API\Client\Model\LiveDocumentCheckResponseData|\Irisnet\API\Client\Model\ApiNotice, HTTP status code, HTTP response headers (array of strings)
     */
    public function liveDocumentCheckWithHttpInfo($configId, $liveDocumentCheckRequestData, string $contentType = self::contentTypes['liveDocumentCheck'][0])
    {
        $request = $this->liveDocumentCheckRequest($configId, $liveDocumentCheckRequestData, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    return $this->handleResponseWithDataType(
                        '\Irisnet\API\Client\Model\LiveDocumentCheckResponseData',
                        $request,
                        $response,
                    );
                case 402:
                    return $this->handleResponseWithDataType(
                        '\Irisnet\API\Client\Model\ApiNotice',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Irisnet\API\Client\Model\LiveDocumentCheckResponseData',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Irisnet\API\Client\Model\LiveDocumentCheckResponseData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Irisnet\API\Client\Model\ApiNotice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation liveDocumentCheckAsync
     *
     * Start a guided live id document check with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  \Irisnet\API\Client\Model\LiveDocumentCheckRequestData $liveDocumentCheckRequestData The LiveDocumentCheckRequestData containing data needed for the live id document check. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['liveDocumentCheck'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function liveDocumentCheckAsync($configId, $liveDocumentCheckRequestData, string $contentType = self::contentTypes['liveDocumentCheck'][0])
    {
        return $this->liveDocumentCheckAsyncWithHttpInfo($configId, $liveDocumentCheckRequestData, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation liveDocumentCheckAsyncWithHttpInfo
     *
     * Start a guided live id document check with the AI.
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  \Irisnet\API\Client\Model\LiveDocumentCheckRequestData $liveDocumentCheckRequestData The LiveDocumentCheckRequestData containing data needed for the live id document check. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['liveDocumentCheck'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function liveDocumentCheckAsyncWithHttpInfo($configId, $liveDocumentCheckRequestData, string $contentType = self::contentTypes['liveDocumentCheck'][0])
    {
        $returnType = '\Irisnet\API\Client\Model\LiveDocumentCheckResponseData';
        $request = $this->liveDocumentCheckRequest($configId, $liveDocumentCheckRequestData, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'liveDocumentCheck'
     *
     * @param  string $configId The configuration id from the Basic Configuration operations. (required)
     * @param  \Irisnet\API\Client\Model\LiveDocumentCheckRequestData $liveDocumentCheckRequestData The LiveDocumentCheckRequestData containing data needed for the live id document check. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['liveDocumentCheck'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function liveDocumentCheckRequest($configId, $liveDocumentCheckRequestData, string $contentType = self::contentTypes['liveDocumentCheck'][0])
    {

        // verify the required parameter 'configId' is set
        if ($configId === null || (is_array($configId) && count($configId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $configId when calling liveDocumentCheck'
            );
        }

        // verify the required parameter 'liveDocumentCheckRequestData' is set
        if ($liveDocumentCheckRequestData === null || (is_array($liveDocumentCheckRequestData) && count($liveDocumentCheckRequestData) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $liveDocumentCheckRequestData when calling liveDocumentCheck'
            );
        }


        $resourcePath = '/v2/check-live-id-document/{configId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($configId !== null) {
            $resourcePath = str_replace(
                '{' . 'configId' . '}',
                ObjectSerializer::toPathValue($configId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($liveDocumentCheckRequestData)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($liveDocumentCheckRequestData));
            } else {
                $httpBody = $liveDocumentCheckRequestData;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('LICENSE-KEY');
        if ($apiKey !== null) {
            $headers['LICENSE-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
